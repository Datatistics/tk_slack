[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "tk_slack",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "tk_slack"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "tk_slack",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall tk_slack in Development mode\n# make sure tk_slack package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to tk_slack\n$ nbdev_prepare",
    "crumbs": [
      "tk_slack"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "tk_slack",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/Datatistics/tk_slack.git\nor from conda\n$ conda install -c Datatistics tk_slack\nor from pypi\n$ pip install tk_slack\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.\n---\nconfig:\n  theme: redux\n  layout: dagre\n  look: handDrawn\n---\nflowchart TD\n subgraph Core_Components[\"Core_Components\"]\n        MessageTemplates[\"MessageTemplates&lt;br&gt;Creates formatted messages\"]\n        BlockBuilder[\"BlockBuilder&lt;br&gt;Builds Slack Block Kit\"]\n        InteractionBuilder[\"InteractionBuilder&lt;br&gt;Creates buttons, selects, etc.\"]\n        ActionIdManager[\"ActionIdManager&lt;br&gt;Generates &amp; parses action IDs\"]\n        MetadataHandler[\"MetadataHandler&lt;br&gt;Attaches/reads hidden metadata\"]\n        ActionHandler[\"ActionHandler&lt;br&gt;Processes user actions\"]\n        TemplateEngine[\"TemplateEngine&lt;br&gt;Transforms data to message blocks\"]\n        SnowflakeConnector[\"SnowflakeConnector&lt;br&gt;Handles DB ops\"]\n  end\n subgraph Message_Creation_Flow[\"Message_Creation_Flow\"]\n        DataInput[\"Data Input (DataFrame)\"]\n        Configuration[\"Apply Configuration\"]\n        BlockBuilding[\"Block Building\"]\n        MetadataAddition[\"Metadata Addition\"]\n        MessageSending[\"Send Message to Slack\"]\n  end\n subgraph User_Interaction_Flow[\"User_Interaction_Flow\"]\n        UserAction[\"User Clicks Element\"]\n        ActionDetection[\"Universal Handler Captures Action\"]\n        MetadataExtraction[\"Extract Metadata\"]\n        ActionProcessing[\"Process Action Logic\"]\n        SnowflakeStorage[\"Store in Snowflake\"]\n        Response[\"Send Slack Response\"]\n  end\n    DataInput --&gt; Configuration\n    Configuration --&gt; BlockBuilding\n    BlockBuilding -- Uses --&gt; TemplateEngine\n    TemplateEngine --&gt; MessageTemplates & BlockBuilder & InteractionBuilder & MetadataAddition\n    InteractionBuilder --&gt; ActionIdManager\n    MetadataAddition --&gt; MetadataHandler & MessageSending\n    UserAction --&gt; ActionDetection\n    ActionDetection --&gt; ActionHandler\n    ActionHandler --&gt; MetadataExtraction & ActionProcessing & TemplateEngine\n    MetadataExtraction --&gt; MetadataHandler\n    ActionProcessing --&gt; SnowflakeStorage & Response\n    SnowflakeStorage --&gt; SnowflakeConnector",
    "crumbs": [
      "tk_slack"
    ]
  },
  {
    "objectID": "API/snowflake_connector.html",
    "href": "API/snowflake_connector.html",
    "title": "snowflake_connector",
    "section": "",
    "text": "Connector class for Snowflake operations related to Slack interactions. Handles connecting to Snowflake and provides methods for data operations.\n\nsource\n\n\n\n SnowflakeConnector (connection_params:Optional[Dict[str,Any]]=None)\n\nConnector class for Snowflake operations related to Slack interactions. Handles connecting to Snowflake and provides methods for data operations.\nFirst, if we want to make a Snowfalke Connection class, we should probably make a way to connect to Snowflake…\nYay! We are now able to connect to Snowflake which is pretty cool. Let’s also make a method to close the connection when we are done with it. This is important because we don’t want to leave connections open and use up resources. We can do this by adding a close method to our class. This method will call the close method on the connection object. We can also add a check to see if the connection is already closed before trying to close it again.\n\nsource\n\n\n\n\n SnowflakeConnector.close ()\n\nClose the Snowflake connection if open.\nAwesome, now we can connect to Snowflake and close the connection when we are done with it. Let’s also add a method to execute a query and return the results. This will be useful for getting data from Snowflake. We can do this by adding an execute_query method to our class. This method will take a query string as an argument and return the results of the query. We can use the cursor object to execute the query and fetch the results.\n\nsource\n\n\n\n\n SnowflakeConnector.execute_query (query:str,\n                                   params:Optional[List[Any]]=None)\n\n*Execute a query and return results as a list of dictionaries.\nArgs: query: SQL query to execute params: Optional parameters for the query\nReturns: List of dictionaries with query results*\n\n\n\nLet’s also create a way to insert data into Snowflake.\n\nsource\n\n\n\n SnowflakeConnector.insert_record (table_name:str, data:Dict[str,Any],\n                                   **kwargs)\n\n*Enhanced function to insert data into Snowflake with improved type handling.\nArgs: table_name: Name of the table to insert into data: Dictionary of data to insert **kwargs: Additional options for insertion\nReturns: ID of the inserted record (if id_field is provided) or True if successful*\nNow that we can insert individual rows, let’s also add a method to insert multiple rows at once\n\nsource\n\n\n\n\n SnowflakeConnector.bulk_insert (table_name:str,\n                                 df:pandas.core.frame.DataFrame, **kwargs)\n\n*Enhanced function to bulk insert DataFrame data into Snowflake with improved type handling.\nArgs: table_name: Name of the table to insert into df: DataFrame with columns matching table structure **kwargs: Additional options for insertion - database: Override default database - schema: Override default schema - auto_timestamp: Add timestamps to standard timestamp fields (default: True) - timezone: Timezone for timestamps (default: ‘America/Chicago’) - debug: Enable debug output (default: False) - batch_size: Rows per batch (default: 10000) - quote_identifiers: Whether to quote identifiers (default: False) - chunk_size: Size of DataFrame chunks to process (default: None) - auto_create_table: Create table if not exists (default: False) - use_column_mapping: Map DataFrame columns to table columns (default: True)\nReturns: True if successful*\n\nsource\n\n\n\n\n SnowflakeConnector.__del__ ()\n\nEnsure connection is closed when object is destroyed.\n\nsource\n\n\n\n\n SnowflakeConnector.get_interaction_summary ()\n\n*Get a summary of interactions by view and action type.\nReturns: Summary statistics*\n\nsource\n\n\n\n\n SnowflakeConnector.get_interactions_by_view (view:str, limit:int=100)\n\n*Get recent interactions for a specific view.\nArgs: view: View name limit: Maximum number of records to return\nReturns: List of interaction records*\n\nsource\n\n\n\n\n SnowflakeConnector.get_user_interactions (user_id:str, limit:int=100)\n\n*Get recent interactions for a specific user.\nArgs: user_id: Slack user ID limit: Maximum number of records to return\nReturns: List of interaction records*",
    "crumbs": [
      "API",
      "snowflake_connector"
    ]
  },
  {
    "objectID": "API/snowflake_connector.html#data-insertion",
    "href": "API/snowflake_connector.html#data-insertion",
    "title": "snowflake_connector",
    "section": "",
    "text": "Let’s also create a way to insert data into Snowflake.\n\nsource\n\n\n\n SnowflakeConnector.insert_record (table_name:str, data:Dict[str,Any],\n                                   **kwargs)\n\n*Enhanced function to insert data into Snowflake with improved type handling.\nArgs: table_name: Name of the table to insert into data: Dictionary of data to insert **kwargs: Additional options for insertion\nReturns: ID of the inserted record (if id_field is provided) or True if successful*\nNow that we can insert individual rows, let’s also add a method to insert multiple rows at once\n\nsource\n\n\n\n\n SnowflakeConnector.bulk_insert (table_name:str,\n                                 df:pandas.core.frame.DataFrame, **kwargs)\n\n*Enhanced function to bulk insert DataFrame data into Snowflake with improved type handling.\nArgs: table_name: Name of the table to insert into df: DataFrame with columns matching table structure **kwargs: Additional options for insertion - database: Override default database - schema: Override default schema - auto_timestamp: Add timestamps to standard timestamp fields (default: True) - timezone: Timezone for timestamps (default: ‘America/Chicago’) - debug: Enable debug output (default: False) - batch_size: Rows per batch (default: 10000) - quote_identifiers: Whether to quote identifiers (default: False) - chunk_size: Size of DataFrame chunks to process (default: None) - auto_create_table: Create table if not exists (default: False) - use_column_mapping: Map DataFrame columns to table columns (default: True)\nReturns: True if successful*\n\nsource\n\n\n\n\n SnowflakeConnector.__del__ ()\n\nEnsure connection is closed when object is destroyed.\n\nsource\n\n\n\n\n SnowflakeConnector.get_interaction_summary ()\n\n*Get a summary of interactions by view and action type.\nReturns: Summary statistics*\n\nsource\n\n\n\n\n SnowflakeConnector.get_interactions_by_view (view:str, limit:int=100)\n\n*Get recent interactions for a specific view.\nArgs: view: View name limit: Maximum number of records to return\nReturns: List of interaction records*\n\nsource\n\n\n\n\n SnowflakeConnector.get_user_interactions (user_id:str, limit:int=100)\n\n*Get recent interactions for a specific user.\nArgs: user_id: Slack user ID limit: Maximum number of records to return\nReturns: List of interaction records*",
    "crumbs": [
      "API",
      "snowflake_connector"
    ]
  },
  {
    "objectID": "API/interection_builder.html",
    "href": "API/interection_builder.html",
    "title": "interaction_builder",
    "section": "",
    "text": "InteractionBuilder\n\nsource\n\nInteractionBuilder\n\n InteractionBuilder ()\n\nUtility class for creating interactive Slack Block Kit elements.\nFirst, let’s start at the top of the message, which would be the message’s header:\n\nsource\n\n\nInteractionBuilder.create_button\n\n InteractionBuilder.create_button (text:str, action_id:str,\n                                   url:Optional[str]=None,\n                                   value:Optional[str]=None,\n                                   style:Optional[str]=None)\n\n*Create a button element for Slack messages.\nArgs: text: Button text action_id: Identifier for the button url: Optional URL for link buttons value: Optional value for the button style: Optional style - “primary” or “danger”\nReturns: Slack block kit button object*\n\ntest_eq(InteractionBuilder.create_button('My Button','button_clicked'),\n        {'type': 'button',\n        'text': {'type': 'plain_text', 'text': 'My Button', 'emoji': True},\n        'action_id': 'button_clicked'})\n\nInteractionBuilder.create_button('My Button','button_clicked')\n\n{'type': 'button',\n 'text': {'type': 'plain_text', 'text': 'My Button', 'emoji': True},\n 'action_id': 'button_clicked'}\n\n\nWe also need a way to turn the action elements into the full action section/block:\n\nsource\n\n\nInteractionBuilder.create_actions_block\n\n InteractionBuilder.create_actions_block (elements:List[Dict[str,Any]])\n\n*Create an actions block for Slack messages.\nArgs: elements: List of interactive elements\nReturns: Slack block kit actions object*\n\ntest_eq(\n    InteractionBuilder.create_actions_block(\n        InteractionBuilder.create_button('Another Button','button_2_clicked')),\n    {'type': 'actions',\n    'elements': {'type': 'button',\n    'text': {'type': 'plain_text', 'text': 'Another Button', 'emoji': True},\n    'action_id': 'button_2_clicked'}}\n)\n\n\nInteractionBuilder.create_actions_block(\n    InteractionBuilder.create_button('Another Button','button_2_clicked')\n)\n\n{'type': 'actions',\n 'elements': {'type': 'button',\n  'text': {'type': 'plain_text', 'text': 'Another Button', 'emoji': True},\n  'action_id': 'button_2_clicked'}}\n\n\n\nsource\n\n\nInteractionBuilder.create_datepicker\n\n InteractionBuilder.create_datepicker (action_id:str, placeholder:str,\n                                       initial_date:Optional[str]=None)\n\n*Create a date picker element.\nArgs: action_id: Identifier for the date picker placeholder: Placeholder text initial_date: Optional initial date (YYYY-MM-DD format)\nReturns: Slack block kit datepicker object*\n\ntest_eq(InteractionBuilder.create_datepicker('start_date','Pick a Start Date'),\n        {'type': 'datepicker',\n            'action_id': 'start_date',\n            'placeholder': {'type': 'plain_text',\n            'text': 'Pick a Start Date',\n            'emoji': True}})\n\nInteractionBuilder.create_datepicker('start_date','Pick a Start Date')\n\n{'type': 'datepicker',\n 'action_id': 'start_date',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Pick a Start Date',\n  'emoji': True}}\n\n\n\nsource\n\n\nInteractionBuilder.create_static_select\n\n InteractionBuilder.create_static_select (action_id:str, placeholder:str,\n                                          options:List[Tuple[str,str]])\n\n*Create a dropdown select element.\nArgs: action_id: Identifier for the select placeholder: Placeholder text options: List of (text, value) tuples for options\nReturns: Slack block kit static_select object*\n\ntest_eq(InteractionBuilder.create_static_select('credit_action','Choose and Action',[('Issue Creidt','issue_credit'),('Ignore','ignore')]),\n        {'type': 'static_select',\n            'action_id': 'credit_action',\n            'placeholder': {'type': 'plain_text',\n            'text': 'Choose and Action',\n            'emoji': True},\n            'options': [{'text': {'type': 'plain_text',\n                'text': 'Issue Creidt',\n                'emoji': True},\n            'value': 'issue_credit'},\n            {'text': {'type': 'plain_text', 'text': 'Ignore', 'emoji': True},\n            'value': 'ignore'}]})\n\nInteractionBuilder.create_static_select('credit_action','Choose and Action',[('Issue Creidt','issue_credit'),('Ignore','ignore')])\n\n{'type': 'static_select',\n 'action_id': 'credit_action',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Choose and Action',\n  'emoji': True},\n 'options': [{'text': {'type': 'plain_text',\n    'text': 'Issue Creidt',\n    'emoji': True},\n   'value': 'issue_credit'},\n  {'text': {'type': 'plain_text', 'text': 'Ignore', 'emoji': True},\n   'value': 'ignore'}]}\n\n\n\nsource\n\n\nInteractionBuilder.create_multi_select\n\n InteractionBuilder.create_multi_select (action_id:str, placeholder:str,\n                                         options:List[Tuple[str,str]])\n\n*Create a multi-select dropdown element.\nArgs: action_id: Identifier for the multi-select placeholder: Placeholder text options: List of (text, value) tuples for options\nReturns: Slack block kit multi_static_select object*\n\ntest_eq(InteractionBuilder.create_multi_select('select_multiple','Select Option(s)',[('One','one'),('Two','two')]),\n        {'type': 'multi_static_select',\n            'action_id': 'select_multiple',\n            'placeholder': {'type': 'plain_text',\n            'text': 'Select Option(s)',\n            'emoji': True},\n            'options': [{'text': {'type': 'plain_text', 'text': 'One', 'emoji': True},\n            'value': 'one'},\n            {'text': {'type': 'plain_text', 'text': 'Two', 'emoji': True},\n            'value': 'two'}]})\n\nInteractionBuilder.create_multi_select('select_multiple','Select Option(s)',[('One','one'),('Two','two')])\n\n{'type': 'multi_static_select',\n 'action_id': 'select_multiple',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Select Option(s)',\n  'emoji': True},\n 'options': [{'text': {'type': 'plain_text', 'text': 'One', 'emoji': True},\n   'value': 'one'},\n  {'text': {'type': 'plain_text', 'text': 'Two', 'emoji': True},\n   'value': 'two'}]}\n\n\n\nsource\n\n\nInteractionBuilder.create_users_select\n\n InteractionBuilder.create_users_select (action_id:str, placeholder:str)\n\n*Create a user select element.\nArgs: action_id: Identifier for the users select placeholder: Placeholder text\nReturns: Slack block kit users_select object*\n\ntest_eq(InteractionBuilder.create_users_select('selected_user','Select a User'),\n        {'type': 'users_select',\n        'action_id': 'selected_user',\n        'placeholder': {'type': 'plain_text', 'text': 'Select a User', 'emoji': True}})\n\nInteractionBuilder.create_users_select('selected_user','Select a User')\n\n{'type': 'users_select',\n 'action_id': 'selected_user',\n 'placeholder': {'type': 'plain_text', 'text': 'Select a User', 'emoji': True}}\n\n\n\nsource\n\n\nInteractionBuilder.create_channels_select\n\n InteractionBuilder.create_channels_select (action_id:str,\n                                            placeholder:str)\n\n*Create a channel select element.\nArgs: action_id: Identifier for the channels select placeholder: Placeholder text\nReturns: Slack block kit channels_select object*\n\ntest_eq(InteractionBuilder.create_channels_select('selected_channel','Select a Channel'),\n        {'type': 'channels_select',\n        'action_id': 'selected_channel',\n        'placeholder': {'type': 'plain_text',\n        'text': 'Select a Channel',\n        'emoji': True}})\n\nInteractionBuilder.create_channels_select('selected_channel','Select a Channel')\n\n{'type': 'channels_select',\n 'action_id': 'selected_channel',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Select a Channel',\n  'emoji': True}}\n\n\n\nsource\n\n\nInteractionBuilder.detect_and_create_interactive_elements\n\n InteractionBuilder.detect_and_create_interactive_elements\n                                                            (option_names:\n                                                            List[str], opt\n                                                            ion_values:Lis\n                                                            t[str], action\n                                                            _type:Optional\n                                                            [str]=None, me\n                                                            tadata:Optiona\n                                                            l[str]=None, v\n                                                            iew_info:Optio\n                                                            nal[Dict[str,A\n                                                            ny]]=None)\n\n*Smartly detect and create appropriate interactive elements.\nArgs: option_names: List of option names option_values: List of option values action_type: Optional explicit action type metadata: Optional metadata to include in action_id view_info: Optional view information for embedding in metadata\nReturns: List of interactive elements*\n\ntest_eq(InteractionBuilder.detect_and_create_interactive_elements(['Start Date'],['start_date'],'selected_start_date'),\n        [{'type': 'button',\n            'text': {'type': 'plain_text', 'text': 'Start Date', 'emoji': True},\n            'action_id': 'tk_interaction_sele_0',\n            'value': 'start_date',\n            'style': 'primary'}])\n\nInteractionBuilder.detect_and_create_interactive_elements(['Start Date'],['start_date'],'selected_start_date')\n\n[{'type': 'button',\n  'text': {'type': 'plain_text', 'text': 'Start Date', 'emoji': True},\n  'action_id': 'tk_interaction_sele_0',\n  'value': 'start_date',\n  'style': 'primary'}]",
    "crumbs": [
      "API",
      "interaction_builder"
    ]
  },
  {
    "objectID": "API/slack_actions.html",
    "href": "API/slack_actions.html",
    "title": "slack_actions",
    "section": "",
    "text": "ActionHandler\n\nsource\n\nActionHandler\n\n ActionHandler ()\n\n*Handles Slack interactive actions, including acknowledgment, response, and storing results in Snowflake.\nImplements a singleton pattern to ensure only one handler exists.*\n\n\nResponding to Actions:\n\n\nStoring Action in Snowflake\nWhen the user interacts with the bot, the action is stored in Snowflake. The action is stored in a table called user_interaction. The table has the following columns:\nWe also need a way to get information about a view in Snowflake:\n\n\n\nActionIdManager\n\nsource\n\nActionIdManager\n\n ActionIdManager ()\n\nManages action IDs for Slack interactive elements to ensure uniqueness and provide routing capabilities for action handlers.\n\ntest_eq(ActionIdManager.generate_action_id(\"button\", 0), \"tk_interaction_btn_0\")\n\ntest_eq(ActionIdManager.parse_action_id(\"tk_interaction_btn_0\"),{'type': 'btn', 'idx': '0', 'action_type': 'button', 'index': 0})\n\nLet’s now update the ActionHandler class to use the new ActionIDManager class.\nLet’s create a method to allow the user to setup the action handler in their slackbot app, and this handler will need to use an instance of the ActionIDManager class to generate a unique action ID for each action. The action ID will be used to identify the action in the Snowflake table\n\nsource\n\n\nActionHandler.setup_slack_action_handler\n\n ActionHandler.setup_slack_action_handler (app)\n\n*Set up a single Slack action handler with the Bolt app.\nArgs: app: Slack Bolt app snowflake_connector: Connector for Snowflake operations\nReturns: Initialized ActionHandler instance*\nWe also need to update the ActionHandler class to use the new ActionIDManager class. When processing actions from the app, it will need to call parse_action_id to get the information from the id\n\nbody_example = {'type': 'block_actions', 'user': {'id': 'U08SWJ7MGDC', 'username': 'cooperrichason', 'name': 'cooperrichason', 'team_id': 'T08SWJ7MGAJ'}, 'api_app_id': 'A08SWJJGW1L', 'token': 'wjBURx2qV2cSMgnUlvDvI7D9', 'container': {'type': 'message', 'message_ts': '1747869345.068909', 'channel_id': 'C08TFTZHY4R', 'is_ephemeral': False}, 'trigger_id': '8931953858965.8914619730358.3acc5cd59b50a162f407f5d3a049a08b', 'team': {'id': 'T08SWJ7MGAJ', 'domain': 'datatistics'}, 'enterprise': None, 'is_enterprise_install': False, 'channel': {'id': 'C08TFTZHY4R', 'name': 'tk_slack'}, 'message': {'user': 'U08TFUY0HND', 'type': 'message', 'ts': '1747869345.068909', 'bot_id': 'B08TFUXV0M7', 'app_id': 'A08SWJJGW1L', 'text': 'Example Data Alert', 'team': 'T08SWJ7MGAJ', 'metadata': {'event_type': 'example_view_notification', 'event_payload': {'view_name': 'example_view', 'view_group': 'examples', 'response_type': 'ephemeral', 'response_message': 'Thanks {user}! You selected \"{text}\" ({value})', 'replace_original': False, 'custom_row_index': 2}}, 'blocks': [{'type': 'section', 'block_id': 'DpeTS', 'text': {'type': 'mrkdwn', 'text': '*Feature Z Implementation*', 'verbatim': False}}, {'type': 'section', 'block_id': 'BOqKS', 'text': {'type': 'mrkdwn', 'text': 'Planning for Feature Z implementation', 'verbatim': False}}, {'type': 'section', 'block_id': '3rZsp', 'fields': [{'type': 'mrkdwn', 'text': '*Name*\\nFeature Z Implementation', 'verbatim': False}, {'type': 'mrkdwn', 'text': '*Text*\\nPlanning for Feature Z implementation', 'verbatim': False}, {'type': 'mrkdwn', 'text': '*Status*\\nIn Progress', 'verbatim': False}, {'type': 'mrkdwn', 'text': '*Priority*\\nHigh', 'verbatim': False}, {'type': 'mrkdwn', 'text': '*Due Date*\\nJun 15, 2025', 'verbatim': False}, {'type': 'mrkdwn', 'text': '*Option Name*\\nStart Work, Assign to Me, Request More Info', 'verbatim': False}, {'type': 'mrkdwn', 'text': '*Option Value*\\nstart, assign_self, request_info', 'verbatim': False}]}, {'type': 'actions', 'block_id': 'WKbX2', 'elements': [{'type': 'button', 'action_id': 'tk_interaction_btn_0', 'text': {'type': 'plain_text', 'text': 'Start Work', 'emoji': True}, 'style': 'primary', 'value': 'start'}, {'type': 'button', 'action_id': 'tk_interaction_btn_1', 'text': {'type': 'plain_text', 'text': 'Assign to Me', 'emoji': True}, 'value': 'assign_self'}, {'type': 'button', 'action_id': 'tk_interaction_btn_2', 'text': {'type': 'plain_text', 'text': 'Request More Info', 'emoji': True}, 'value': 'request_info'}]}, {'type': 'divider', 'block_id': 'MnqyR'}]}, 'state': {'values': {}}, 'response_url': 'https://hooks.slack.com/actions/T08SWJ7MGAJ/8931953776821/BeYdqU9hrCKACdosBdn9GVBA', 'actions': [{'action_id': 'tk_interaction_btn_0', 'block_id': 'WKbX2', 'text': {'type': 'plain_text', 'text': 'Start Work', 'emoji': True}, 'value': 'start', 'style': 'primary', 'type': 'button', 'action_ts': '1747870391.878433'}]}\nbody_example\n\n{'type': 'block_actions',\n 'user': {'id': 'U08SWJ7MGDC',\n  'username': 'cooperrichason',\n  'name': 'cooperrichason',\n  'team_id': 'T08SWJ7MGAJ'},\n 'api_app_id': 'A08SWJJGW1L',\n 'token': 'wjBURx2qV2cSMgnUlvDvI7D9',\n 'container': {'type': 'message',\n  'message_ts': '1747869345.068909',\n  'channel_id': 'C08TFTZHY4R',\n  'is_ephemeral': False},\n 'trigger_id': '8931953858965.8914619730358.3acc5cd59b50a162f407f5d3a049a08b',\n 'team': {'id': 'T08SWJ7MGAJ', 'domain': 'datatistics'},\n 'enterprise': None,\n 'is_enterprise_install': False,\n 'channel': {'id': 'C08TFTZHY4R', 'name': 'tk_slack'},\n 'message': {'user': 'U08TFUY0HND',\n  'type': 'message',\n  'ts': '1747869345.068909',\n  'bot_id': 'B08TFUXV0M7',\n  'app_id': 'A08SWJJGW1L',\n  'text': 'Example Data Alert',\n  'team': 'T08SWJ7MGAJ',\n  'metadata': {'event_type': 'example_view_notification',\n   'event_payload': {'view_name': 'example_view',\n    'view_group': 'examples',\n    'response_type': 'ephemeral',\n    'response_message': 'Thanks {user}! You selected \"{text}\" ({value})',\n    'replace_original': False,\n    'custom_row_index': 2}},\n  'blocks': [{'type': 'section',\n    'block_id': 'DpeTS',\n    'text': {'type': 'mrkdwn',\n     'text': '*Feature Z Implementation*',\n     'verbatim': False}},\n   {'type': 'section',\n    'block_id': 'BOqKS',\n    'text': {'type': 'mrkdwn',\n     'text': 'Planning for Feature Z implementation',\n     'verbatim': False}},\n   {'type': 'section',\n    'block_id': '3rZsp',\n    'fields': [{'type': 'mrkdwn',\n      'text': '*Name*\\nFeature Z Implementation',\n      'verbatim': False},\n     {'type': 'mrkdwn',\n      'text': '*Text*\\nPlanning for Feature Z implementation',\n      'verbatim': False},\n     {'type': 'mrkdwn', 'text': '*Status*\\nIn Progress', 'verbatim': False},\n     {'type': 'mrkdwn', 'text': '*Priority*\\nHigh', 'verbatim': False},\n     {'type': 'mrkdwn', 'text': '*Due Date*\\nJun 15, 2025', 'verbatim': False},\n     {'type': 'mrkdwn',\n      'text': '*Option Name*\\nStart Work, Assign to Me, Request More Info',\n      'verbatim': False},\n     {'type': 'mrkdwn',\n      'text': '*Option Value*\\nstart, assign_self, request_info',\n      'verbatim': False}]},\n   {'type': 'actions',\n    'block_id': 'WKbX2',\n    'elements': [{'type': 'button',\n      'action_id': 'tk_interaction_btn_0',\n      'text': {'type': 'plain_text', 'text': 'Start Work', 'emoji': True},\n      'style': 'primary',\n      'value': 'start'},\n     {'type': 'button',\n      'action_id': 'tk_interaction_btn_1',\n      'text': {'type': 'plain_text', 'text': 'Assign to Me', 'emoji': True},\n      'value': 'assign_self'},\n     {'type': 'button',\n      'action_id': 'tk_interaction_btn_2',\n      'text': {'type': 'plain_text',\n       'text': 'Request More Info',\n       'emoji': True},\n      'value': 'request_info'}]},\n   {'type': 'divider', 'block_id': 'MnqyR'}]},\n 'state': {'values': {}},\n 'response_url': 'https://hooks.slack.com/actions/T08SWJ7MGAJ/8931953776821/BeYdqU9hrCKACdosBdn9GVBA',\n 'actions': [{'action_id': 'tk_interaction_btn_0',\n   'block_id': 'WKbX2',\n   'text': {'type': 'plain_text', 'text': 'Start Work', 'emoji': True},\n   'value': 'start',\n   'style': 'primary',\n   'type': 'button',\n   'action_ts': '1747870391.878433'}]}\n\n\n\nsource\n\n\nActionHandler.process_slack_action\n\n ActionHandler.process_slack_action (body:Dict[str,Any], respond:Callable)\n\n*Process a Slack action event.\nArgs: body: Slack event body respond: Slack respond function\nReturns: Processed action data*",
    "crumbs": [
      "API",
      "slack_actions"
    ]
  },
  {
    "objectID": "API/template_engine.html",
    "href": "API/template_engine.html",
    "title": "template_engine",
    "section": "",
    "text": "source\n\nTemplateEngine\n\n TemplateEngine ()\n\nCore template engine for creating Slack messages from DataFrame data. Provides methods to generate messages in different formats.\n\nsource\n\n\nTemplateEngine.build_individual_message_blocks\n\n TemplateEngine.build_individual_message_blocks\n                                                 (row:pandas.core.series.S\n                                                 eries,\n                                                 df_columns:List[str],\n                                                 col_map:Dict[str,str],\n                                                 config:Dict[str,Any])\n\n*Build message blocks for a single row.\nArgs: row: DataFrame row df_columns: DataFrame column names col_map: Column name mapping config: Configuration dictionary\nReturns: List of Slack blocks for the message*",
    "crumbs": [
      "API",
      "template_engine"
    ]
  },
  {
    "objectID": "API/metadata_handler.html",
    "href": "API/metadata_handler.html",
    "title": "metadata_handler",
    "section": "",
    "text": "Metadata will be an important component for allowing TriggerKit to make and react to interactive messages.\nWe need to allow users to: - encode metadata in their messages - retrieve metadata from user interactions in the Snowflake Table\nThe means tk_slakc needs to: - Encode the specified metadata into the message - Retrieve the metadata from messages - Send the metadata with the user interaction to Snowflake\n\nsource\n\nMessageMetadataHandler\n\n MessageMetadataHandler ()\n\n*Handles the creation and attachment of metadata to Slack messages.\nThis class implements Slack’s message metadata feature which allows attaching invisible structured data to messages for event-driven processing.\nReference: https://api.slack.com/metadata*\n\nsource\n\n\nMessageMetadataHandler.create_metadata\n\n MessageMetadataHandler.create_metadata (event_type:str,\n                                         view_info:Optional[Dict[str,Any]]\n                                         =None, response_config:Optional[D\n                                         ict[str,Any]]=None, custom_data:O\n                                         ptional[Dict[str,Any]]=None)\n\n*Create structured metadata for a Slack message.\nArgs: event_type: Type of event (e.g., ‘lead_alert’, ‘data_notification’) view_info: Optional information about the Snowflake view that generated this message response_config: Optional configuration for how to respond to user actions custom_data: Optional additional custom data to include\nReturns: Properly formatted metadata dictionary*\n\nsource\n\n\nMessageMetadataHandler.add_metadata_to_message\n\n MessageMetadataHandler.add_metadata_to_message (message:Dict[str,Any],\n                                                 event_type:str, view_info\n                                                 :Optional[Dict[str,Any]]=\n                                                 None, response_config:Opt\n                                                 ional[Dict[str,Any]]=None\n                                                 , custom_data:Optional[Di\n                                                 ct[str,Any]]=None)\n\n*Add metadata to a Slack message payload.\nArgs: message: Slack message payload event_type: Type of event view_info: Optional view information response_config: Optional response configuration custom_data: Optional additional custom data\nReturns: Message with metadata attached*\n\nsource\n\n\nMessageMetadataHandler.extract_metadata_from_message\n\n MessageMetadataHandler.extract_metadata_from_message\n                                                       (message:Dict[str,A\n                                                       ny])\n\n*Extract metadata from a Slack message.\nArgs: message: Slack message with metadata\nReturns: Extracted metadata or empty dict if none*\n\nsource\n\n\nMessageMetadataHandler.get_event_payload\n\n MessageMetadataHandler.get_event_payload (message:Dict[str,Any])\n\n*Get the event payload from a message’s metadata.\nArgs: message: Slack message with metadata\nReturns: Event payload or empty dict if none*",
    "crumbs": [
      "API",
      "metadata_handler"
    ]
  },
  {
    "objectID": "API/block_builder.html",
    "href": "API/block_builder.html",
    "title": "block_builder",
    "section": "",
    "text": "source\n\n\n\n BlockBuilder ()\n\nUtility class for building Slack Block Kit elements. Provides methods to create various block types for Slack messages.\nFirst, let’s start at the top of the message, which would be the message’s header:\n\nsource\n\n\n\n\n BlockBuilder.create_header_block (text:str)\n\n*Create a header block for Slack messages.\nArgs: text: The text to display in the header\nReturns: Slack block kit header object*\n\ntest_eq(BlockBuilder.create_header_block('My Text'),{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}})\n\nBlockBuilder.create_header_block('My Text')\n\n{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}}\n\n\nThat looks correct!\nNow, what about making the various sections in our message? We basically just need another simple method that takes in the section text and outputs the right formating for the Slack API\n\nsource\n\n\n\n\n BlockBuilder.create_section_block (text:str,\n                                    fields:Optional[List[Dict[str,Any]]]=N\n                                    one)\n\n*Create a section block for Slack messages.\nArgs: text: The text to display in the section fields: Optional list of field objects for the section\nReturns: Slack block kit section object*\n\ntest_eq(BlockBuilder.create_section_block('My Section'),{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n)\n\nBlockBuilder.create_section_block('My Section')\n\n{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n\n\nOR, if we want the section to have some detial fields:\n\ntest_eq(BlockBuilder.create_section_block('My Section',['Some Field here']),\n        {'type': 'section','text': {'type': 'mrkdwn', 'text': 'My Section'},'fields': ['Some Field here']})\n\n\nBlockBuilder.create_section_block('My Section',['Some Field here'])\n\n{'type': 'section',\n 'text': {'type': 'mrkdwn', 'text': 'My Section'},\n 'fields': ['Some Field here']}\n\n\nPerfect! I guess we should should actually make a way to make fields then:\n\nsource\n\n\n\n\n BlockBuilder.create_field (title:str, value:str)\n\n*Create a field for a section block.\nArgs: title: The title of the field (will be bolded) value: The value of the field\nReturns: Field object for use in section blocks*\n\ntest_eq(BlockBuilder.create_field('The Top, Important Part','Less important Part'),\n        {'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'})\n\nBlockBuilder.create_field('The Top, Important Part','Less important Part')\n\n{'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'}\n\n\nThat would be used for things like BlockBuilder.create_field(column_name,row_value) to add the column details to the message\nNow that we can make an individual field, let’s make a way to take in multiple fields and turn them into a section since we’ll often want to show the values for multiple columns:\n\nsource\n\n\n\n\n BlockBuilder.create_fields_section (fields_data:List[Tuple[str,str]],\n                                     max_fields_per_section:int=10)\n\n*Create one or more section blocks with fields.\nArgs: fields_data: List of (label, value) tuples max_fields_per_section: Maximum fields per section (Slack limit is 10)\nReturns: List of section blocks*\nLet’s pretend we are trying to make a section that has fiels for a center’s billing rate and company status since we send some alerts that do that:\n\nBlockBuilder.create_fields_section([('Billing Rate','$13'),('Company Status','Advertiser')])\n\n[{'type': 'section',\n  'fields': [{'type': 'mrkdwn', 'text': '*Billing Rate*\\n$13'},\n   {'type': 'mrkdwn', 'text': '*Company Status*\\nAdvertiser'}]}]\n\n\n\n\n\nsection_fields.png\n\n\nWow, that looks great!\nLet’s also add a method for making context blocks since that is a subtle way to add text/information to a message.\n\nsource\n\n\n\n\n BlockBuilder.create_context_block (text:str)\n\n*Create a context block for Slack messages.\nArgs: text: The text to show in the context block\nReturns: Slack block kit context object*\n\ntest_eq(BlockBuilder.create_context_block('Here is some informaiton'),{'type': 'context','elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]})\n\nBlockBuilder.create_context_block('Here is some informaiton')\n\n{'type': 'context',\n 'elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]}\n\n\nWe also probably want a way to make dividers since those are always helpful for layout messages:\n\nsource\n\n\n\n\n BlockBuilder.create_divider ()\n\n*Create a divider block for Slack messages.\nReturns: Slack block kit divider object*\n\ntest_eq(BlockBuilder.create_divider(),{'type': 'divider'})\n\nBlockBuilder.create_divider()\n\n{'type': 'divider'}\n\n\nSince would like to allow users to add metadata to messages (which is helpful for processing the messages by the slack bot), let’s also create a method for turning column values into message context:\n\nsource\n\n\n\n\n BlockBuilder.create_metadata_context\n                                       (metadata_items:List[Tuple[str,Unio\n                                       n[str,List,dict]]])\n\n*Create a context block for metadata items.\nArgs: metadata_items: List of (label, value) tuples\nReturns: Formatted metadata field*\n\ntest_eq(\n    BlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})]),\n    {'metadata': \n        {'Sheet Owner': 'Mary',\n        'Sheet Editors': ['Joe', 'John', 'Bill'],\n        'Budfet': {\n            'Shared': False,\n            'Uses Parent': False,\n            'individual_budget': 9000}}})\n\n\nBlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})])\n\n{'metadata': {'Sheet Owner': 'Mary',\n  'Sheet Editors': ['Joe', 'John', 'Bill'],\n  'Budfet': {'Shared': False,\n   'Uses Parent': False,\n   'individual_budget': 9000}}}",
    "crumbs": [
      "API",
      "block_builder"
    ]
  },
  {
    "objectID": "API/block_builder.html#creating-a-slack-builder-class",
    "href": "API/block_builder.html#creating-a-slack-builder-class",
    "title": "block_builder",
    "section": "",
    "text": "source\n\n\n\n BlockBuilder ()\n\nUtility class for building Slack Block Kit elements. Provides methods to create various block types for Slack messages.\nFirst, let’s start at the top of the message, which would be the message’s header:\n\nsource\n\n\n\n\n BlockBuilder.create_header_block (text:str)\n\n*Create a header block for Slack messages.\nArgs: text: The text to display in the header\nReturns: Slack block kit header object*\n\ntest_eq(BlockBuilder.create_header_block('My Text'),{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}})\n\nBlockBuilder.create_header_block('My Text')\n\n{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}}\n\n\nThat looks correct!\nNow, what about making the various sections in our message? We basically just need another simple method that takes in the section text and outputs the right formating for the Slack API\n\nsource\n\n\n\n\n BlockBuilder.create_section_block (text:str,\n                                    fields:Optional[List[Dict[str,Any]]]=N\n                                    one)\n\n*Create a section block for Slack messages.\nArgs: text: The text to display in the section fields: Optional list of field objects for the section\nReturns: Slack block kit section object*\n\ntest_eq(BlockBuilder.create_section_block('My Section'),{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n)\n\nBlockBuilder.create_section_block('My Section')\n\n{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n\n\nOR, if we want the section to have some detial fields:\n\ntest_eq(BlockBuilder.create_section_block('My Section',['Some Field here']),\n        {'type': 'section','text': {'type': 'mrkdwn', 'text': 'My Section'},'fields': ['Some Field here']})\n\n\nBlockBuilder.create_section_block('My Section',['Some Field here'])\n\n{'type': 'section',\n 'text': {'type': 'mrkdwn', 'text': 'My Section'},\n 'fields': ['Some Field here']}\n\n\nPerfect! I guess we should should actually make a way to make fields then:\n\nsource\n\n\n\n\n BlockBuilder.create_field (title:str, value:str)\n\n*Create a field for a section block.\nArgs: title: The title of the field (will be bolded) value: The value of the field\nReturns: Field object for use in section blocks*\n\ntest_eq(BlockBuilder.create_field('The Top, Important Part','Less important Part'),\n        {'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'})\n\nBlockBuilder.create_field('The Top, Important Part','Less important Part')\n\n{'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'}\n\n\nThat would be used for things like BlockBuilder.create_field(column_name,row_value) to add the column details to the message\nNow that we can make an individual field, let’s make a way to take in multiple fields and turn them into a section since we’ll often want to show the values for multiple columns:\n\nsource\n\n\n\n\n BlockBuilder.create_fields_section (fields_data:List[Tuple[str,str]],\n                                     max_fields_per_section:int=10)\n\n*Create one or more section blocks with fields.\nArgs: fields_data: List of (label, value) tuples max_fields_per_section: Maximum fields per section (Slack limit is 10)\nReturns: List of section blocks*\nLet’s pretend we are trying to make a section that has fiels for a center’s billing rate and company status since we send some alerts that do that:\n\nBlockBuilder.create_fields_section([('Billing Rate','$13'),('Company Status','Advertiser')])\n\n[{'type': 'section',\n  'fields': [{'type': 'mrkdwn', 'text': '*Billing Rate*\\n$13'},\n   {'type': 'mrkdwn', 'text': '*Company Status*\\nAdvertiser'}]}]\n\n\n\n\n\nsection_fields.png\n\n\nWow, that looks great!\nLet’s also add a method for making context blocks since that is a subtle way to add text/information to a message.\n\nsource\n\n\n\n\n BlockBuilder.create_context_block (text:str)\n\n*Create a context block for Slack messages.\nArgs: text: The text to show in the context block\nReturns: Slack block kit context object*\n\ntest_eq(BlockBuilder.create_context_block('Here is some informaiton'),{'type': 'context','elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]})\n\nBlockBuilder.create_context_block('Here is some informaiton')\n\n{'type': 'context',\n 'elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]}\n\n\nWe also probably want a way to make dividers since those are always helpful for layout messages:\n\nsource\n\n\n\n\n BlockBuilder.create_divider ()\n\n*Create a divider block for Slack messages.\nReturns: Slack block kit divider object*\n\ntest_eq(BlockBuilder.create_divider(),{'type': 'divider'})\n\nBlockBuilder.create_divider()\n\n{'type': 'divider'}\n\n\nSince would like to allow users to add metadata to messages (which is helpful for processing the messages by the slack bot), let’s also create a method for turning column values into message context:\n\nsource\n\n\n\n\n BlockBuilder.create_metadata_context\n                                       (metadata_items:List[Tuple[str,Unio\n                                       n[str,List,dict]]])\n\n*Create a context block for metadata items.\nArgs: metadata_items: List of (label, value) tuples\nReturns: Formatted metadata field*\n\ntest_eq(\n    BlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})]),\n    {'metadata': \n        {'Sheet Owner': 'Mary',\n        'Sheet Editors': ['Joe', 'John', 'Bill'],\n        'Budfet': {\n            'Shared': False,\n            'Uses Parent': False,\n            'individual_budget': 9000}}})\n\n\nBlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})])\n\n{'metadata': {'Sheet Owner': 'Mary',\n  'Sheet Editors': ['Joe', 'John', 'Bill'],\n  'Budfet': {'Shared': False,\n   'Uses Parent': False,\n   'individual_budget': 9000}}}",
    "crumbs": [
      "API",
      "block_builder"
    ]
  },
  {
    "objectID": "API/core.html",
    "href": "API/core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nDebugLogger\n\n DebugLogger ()\n\nSimple debug logger to centralize logging logic.\n\nsource\n\n\nColumnUtils\n\n ColumnUtils ()\n\nUtilities for column operations in DataFrames.\n\nsource\n\n\nValueFormatter\n\n ValueFormatter ()\n\nHandles formatting of different data types for display.\n\nsource\n\n\nSlackFormatter\n\n SlackFormatter ()\n\nUtilities for formatting data for Slack messages.\n\nsource\n\n\nSlackMessenger\n\n SlackMessenger ()\n\nHandles creation and sending of Slack messages in various templates.",
    "crumbs": [
      "API",
      "core"
    ]
  },
  {
    "objectID": "API/message_templates.html",
    "href": "API/message_templates.html",
    "title": "message_templates",
    "section": "",
    "text": "source\n\nMessageTemplate\n\n MessageTemplate ()\n\nRefactored templates using modular components.\n\nsource\n\n\nMessageTemplate.template_f1\n\n MessageTemplate.template_f1 (df:pandas.core.frame.DataFrame, view:str,\n                              view_group:str, message_text:str,\n                              channel_id:str, view_config:Dict[str,Any],\n                              send_to_slack_func:Callable=None,\n                              log_alert_history_func:Callable=None)\n\n*Slack Message Format 1: Single message with row sections and details on the right.\nArgs: df: DataFrame with alert data view: View name view_group: Group name for the view message_text: Main message text channel_id: Slack channel ID view_config: Configuration for the view send_to_slack_func: Function to send messages to Slack log_alert_history_func: Function to log alert history\nReturns: Tuple of (success_flag, error_details)*\n\nsource\n\n\nMessageTemplate.template_f2\n\n MessageTemplate.template_f2 (df:pandas.core.frame.DataFrame, view:str,\n                              view_group:str, message_text:str,\n                              channel_id:str,\n                              view_config:Dict[str,Any]=None,\n                              send_to_slack_func:Callable=None,\n                              log_alert_history_func:Callable=None)\n\n*Slack Message Format 2: Individual interactive messages for each row.\nArgs: df: DataFrame with alert data view: View name view_group: Group name for the view message_text: Main message text channel_id: Slack channel ID view_config: Configuration for the view send_to_slack_func: Function to send messages to Slack log_alert_history_func: Function to log alert history\nReturns: Tuple of (success_flag, error_details)*",
    "crumbs": [
      "API",
      "message_templates"
    ]
  }
]