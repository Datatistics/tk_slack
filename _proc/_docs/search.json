[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "tk_slack",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "tk_slack"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "tk_slack",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall tk_slack in Development mode\n# make sure tk_slack package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to tk_slack\n$ nbdev_prepare",
    "crumbs": [
      "tk_slack"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "tk_slack",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/Datatistics/tk_slack.git\nor from conda\n$ conda install -c Datatistics tk_slack\nor from pypi\n$ pip install tk_slack\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "tk_slack"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "tk_slack",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2",
    "crumbs": [
      "tk_slack"
    ]
  },
  {
    "objectID": "API/interection_builder.html",
    "href": "API/interection_builder.html",
    "title": "interaction_builder",
    "section": "",
    "text": "SnowflakeConnector\nConnector class for Snowflake operations related to Slack interactions. Handles connecting to Snowflake and provides methods for data operations.\n\n\nSnowflakeConnector\n\n SnowflakeConnector (connection_params:Optional[Dict[str,Any]]=None)\n\nConnector class for Snowflake operations related to Slack interactions. Handles connecting to Snowflake and provides methods for data operations.\n\n\n\nActionHandler\n\nsource\n\nActionHandler\n\n ActionHandler (snowflake_connector)\n\n*Handles Slack interactive actions, including acknowledgment, response, and storing results in Snowflake.\nImplements a singleton pattern to ensure only one handler exists.*\n\n\nResponding to Actions:\n\n\nStoring Action in Snowflake\nWhen the user interacts with the bot, the action is stored in Snowflake. The action is stored in a table called user_interaction. The table has the following columns:\nWe also need a way to get information about a view in Snowflake:\n\n\n\nActionIdManager\n\nsource\n\nActionIdManager\n\n ActionIdManager ()\n\nManages action IDs for Slack interactive elements to ensure uniqueness and provide routing capabilities for action handlers.\nLet’s now update the ActionHandler class to use the new ActionIDManager class.\nLet’s create a method to allow the user to setup the action handler in their slackbot app, and this handler will need to use an instance of the ActionIDManager class to generate a unique action ID for each action. The action ID will be used to identify the action in the Snowflake table\n\nsource\n\n\nActionHandler.setup_slack_action_handler\n\n ActionHandler.setup_slack_action_handler (app, snowflake_connector)\n\n*Set up a single Slack action handler with the Bolt app.\nArgs: app: Slack Bolt app snowflake_connector: Connector for Snowflake operations*\nWe also need to update the ActionHandler class to use the new ActionIDManager class. When processing actions from the app, it will need to call parse_action_id to get the information from the id\n\nsource\n\n\nActionHandler.process_action\n\n ActionHandler.process_action (body:Dict[str,Any], respond:Callable,\n                               components:Optional[Dict[str,Any]]=None)\n\n*Process a Slack action event.\nArgs: body: Slack event body respond: Slack respond function components: Optional pre-parsed action ID components\nReturns: Processed action data*\n\n\n\nInteractionBuilder\n\nsource\n\nInteractionBuilder\n\n InteractionBuilder ()\n\nUtility class for creating interactive Slack Block Kit elements.\nFirst, let’s start at the top of the message, which would be the message’s header:\n\nsource\n\n\nInteractionBuilder.create_button\n\n InteractionBuilder.create_button (text:str, action_id:str,\n                                   url:Optional[str]=None,\n                                   value:Optional[str]=None,\n                                   style:Optional[str]=None)\n\n*Create a button element for Slack messages.\nArgs: text: Button text action_id: Identifier for the button url: Optional URL for link buttons value: Optional value for the button style: Optional style - “primary” or “danger”\nReturns: Slack block kit button object*\n\ntest_eq(InteractionBuilder.create_button('My Button','button_clicked'),\n        {'type': 'button',\n        'text': {'type': 'plain_text', 'text': 'My Button', 'emoji': True},\n        'action_id': 'button_clicked'})\n\nInteractionBuilder.create_button('My Button','button_clicked')\n\n{'type': 'button',\n 'text': {'type': 'plain_text', 'text': 'My Button', 'emoji': True},\n 'action_id': 'button_clicked'}\n\n\nWe also need a way to turn the action elements into the full action section/block:\n\nsource\n\n\nInteractionBuilder.create_actions_block\n\n InteractionBuilder.create_actions_block (elements:List[Dict[str,Any]])\n\n*Create an actions block for Slack messages.\nArgs: elements: List of interactive elements\nReturns: Slack block kit actions object*\n\ntest_eq(\n    InteractionBuilder.create_actions_block(\n        InteractionBuilder.create_button('Another Button','button_2_clicked')),\n    {'type': 'actions',\n    'elements': {'type': 'button',\n    'text': {'type': 'plain_text', 'text': 'Another Button', 'emoji': True},\n    'action_id': 'button_2_clicked'}}\n)\n\n\nInteractionBuilder.create_actions_block(\n    InteractionBuilder.create_button('Another Button','button_2_clicked')\n)\n\n{'type': 'actions',\n 'elements': {'type': 'button',\n  'text': {'type': 'plain_text', 'text': 'Another Button', 'emoji': True},\n  'action_id': 'button_2_clicked'}}\n\n\n\nsource\n\n\nInteractionBuilder.create_datepicker\n\n InteractionBuilder.create_datepicker (action_id:str, placeholder:str,\n                                       initial_date:Optional[str]=None)\n\n*Create a date picker element.\nArgs: action_id: Identifier for the date picker placeholder: Placeholder text initial_date: Optional initial date (YYYY-MM-DD format)\nReturns: Slack block kit datepicker object*\n\ntest_eq(InteractionBuilder.create_datepicker('start_date','Pick a Start Date'),\n        {'type': 'datepicker',\n            'action_id': 'start_date',\n            'placeholder': {'type': 'plain_text',\n            'text': 'Pick a Start Date',\n            'emoji': True}})\n\nInteractionBuilder.create_datepicker('start_date','Pick a Start Date')\n\n{'type': 'datepicker',\n 'action_id': 'start_date',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Pick a Start Date',\n  'emoji': True}}\n\n\n\nsource\n\n\nInteractionBuilder.create_static_select\n\n InteractionBuilder.create_static_select (action_id:str, placeholder:str,\n                                          options:List[Tuple[str,str]])\n\n*Create a dropdown select element.\nArgs: action_id: Identifier for the select placeholder: Placeholder text options: List of (text, value) tuples for options\nReturns: Slack block kit static_select object*\n\ntest_eq(InteractionBuilder.create_static_select('credit_action','Choose and Action',[('Issue Creidt','issue_credit'),('Ignore','ignore')]),\n        {'type': 'static_select',\n            'action_id': 'credit_action',\n            'placeholder': {'type': 'plain_text',\n            'text': 'Choose and Action',\n            'emoji': True},\n            'options': [{'text': {'type': 'plain_text',\n                'text': 'Issue Creidt',\n                'emoji': True},\n            'value': 'issue_credit'},\n            {'text': {'type': 'plain_text', 'text': 'Ignore', 'emoji': True},\n            'value': 'ignore'}]})\n\nInteractionBuilder.create_static_select('credit_action','Choose and Action',[('Issue Creidt','issue_credit'),('Ignore','ignore')])\n\n{'type': 'static_select',\n 'action_id': 'credit_action',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Choose and Action',\n  'emoji': True},\n 'options': [{'text': {'type': 'plain_text',\n    'text': 'Issue Creidt',\n    'emoji': True},\n   'value': 'issue_credit'},\n  {'text': {'type': 'plain_text', 'text': 'Ignore', 'emoji': True},\n   'value': 'ignore'}]}\n\n\n\nsource\n\n\nInteractionBuilder.create_multi_select\n\n InteractionBuilder.create_multi_select (action_id:str, placeholder:str,\n                                         options:List[Tuple[str,str]])\n\n*Create a multi-select dropdown element.\nArgs: action_id: Identifier for the multi-select placeholder: Placeholder text options: List of (text, value) tuples for options\nReturns: Slack block kit multi_static_select object*\n\ntest_eq(InteractionBuilder.create_multi_select('select_multiple','Select Option(s)',[('One','one'),('Two','two')]),\n        {'type': 'multi_static_select',\n            'action_id': 'select_multiple',\n            'placeholder': {'type': 'plain_text',\n            'text': 'Select Option(s)',\n            'emoji': True},\n            'options': [{'text': {'type': 'plain_text', 'text': 'One', 'emoji': True},\n            'value': 'one'},\n            {'text': {'type': 'plain_text', 'text': 'Two', 'emoji': True},\n            'value': 'two'}]})\n\nInteractionBuilder.create_multi_select('select_multiple','Select Option(s)',[('One','one'),('Two','two')])\n\n{'type': 'multi_static_select',\n 'action_id': 'select_multiple',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Select Option(s)',\n  'emoji': True},\n 'options': [{'text': {'type': 'plain_text', 'text': 'One', 'emoji': True},\n   'value': 'one'},\n  {'text': {'type': 'plain_text', 'text': 'Two', 'emoji': True},\n   'value': 'two'}]}\n\n\n\nsource\n\n\nInteractionBuilder.create_users_select\n\n InteractionBuilder.create_users_select (action_id:str, placeholder:str)\n\n*Create a user select element.\nArgs: action_id: Identifier for the users select placeholder: Placeholder text\nReturns: Slack block kit users_select object*\n\ntest_eq(InteractionBuilder.create_users_select('selected_user','Select a User'),\n        {'type': 'users_select',\n        'action_id': 'selected_user',\n        'placeholder': {'type': 'plain_text', 'text': 'Select a User', 'emoji': True}})\n\nInteractionBuilder.create_users_select('selected_user','Select a User')\n\n{'type': 'users_select',\n 'action_id': 'selected_user',\n 'placeholder': {'type': 'plain_text', 'text': 'Select a User', 'emoji': True}}\n\n\n\nsource\n\n\nInteractionBuilder.create_channels_select\n\n InteractionBuilder.create_channels_select (action_id:str,\n                                            placeholder:str)\n\n*Create a channel select element.\nArgs: action_id: Identifier for the channels select placeholder: Placeholder text\nReturns: Slack block kit channels_select object*\n\ntest_eq(InteractionBuilder.create_channels_select('selected_channel','Select a Channel'),\n        {'type': 'channels_select',\n        'action_id': 'selected_channel',\n        'placeholder': {'type': 'plain_text',\n        'text': 'Select a Channel',\n        'emoji': True}})\n\nInteractionBuilder.create_channels_select('selected_channel','Select a Channel')\n\n{'type': 'channels_select',\n 'action_id': 'selected_channel',\n 'placeholder': {'type': 'plain_text',\n  'text': 'Select a Channel',\n  'emoji': True}}\n\n\n\nsource\n\n\nInteractionBuilder.detect_and_create_interactive_elements\n\n InteractionBuilder.detect_and_create_interactive_elements\n                                                            (option_names:\n                                                            List[str], opt\n                                                            ion_values:Lis\n                                                            t[str], action\n                                                            _type:Optional\n                                                            [str]=None, me\n                                                            tadata:Optiona\n                                                            l[str]=None, v\n                                                            iew_info:Optio\n                                                            nal[Dict[str,A\n                                                            ny]]=None)\n\n*Smartly detect and create appropriate interactive elements.\nArgs: option_names: List of option names option_values: List of option values action_type: Optional explicit action type metadata: Optional metadata to include in action_id view_info: Optional view information for embedding in metadata\nReturns: List of interactive elements*\n\ntest_eq(InteractionBuilder.detect_and_create_interactive_elements(['Start Date'],['start_date'],'selected_start_date'),\n        [{'type': 'button',\n            'text': {'type': 'plain_text', 'text': 'Start Date', 'emoji': True},\n            'action_id': 'selected_start_date_0',\n            'value': 'start_date',\n            'style': 'primary'}])\n\nInteractionBuilder.detect_and_create_interactive_elements(['Start Date'],['start_date'],'selected_start_date')\n\n[{'type': 'button',\n  'text': {'type': 'plain_text', 'text': 'Start Date', 'emoji': True},\n  'action_id': 'selected_start_date_0',\n  'value': 'start_date',\n  'style': 'primary'}]",
    "crumbs": [
      "API",
      "interaction_builder"
    ]
  },
  {
    "objectID": "API/template_engine.html",
    "href": "API/template_engine.html",
    "title": "template_engine",
    "section": "",
    "text": "source\n\nTemplateEngine\n\n TemplateEngine ()\n\nCore template engine for creating Slack messages from DataFrame data. Provides methods to generate messages in different formats.\n\nsource\n\n\nTemplateEngine.build_individual_message_blocks\n\n TemplateEngine.build_individual_message_blocks\n                                                 (row:pandas.core.series.S\n                                                 eries,\n                                                 df_columns:List[str],\n                                                 col_map:Dict[str,str],\n                                                 config:Dict[str,Any],\n                                                 view:str)\n\n*Build message blocks for a single row.\nArgs: row: DataFrame row df_columns: DataFrame column names col_map: Column name mapping config: Configuration dictionary view: View name for action IDs\nReturns: List of Slack blocks for the message*",
    "crumbs": [
      "API",
      "template_engine"
    ]
  },
  {
    "objectID": "API/block_builder.html",
    "href": "API/block_builder.html",
    "title": "block_builder",
    "section": "",
    "text": "source\n\n\n\n BlockBuilder ()\n\nUtility class for building Slack Block Kit elements. Provides methods to create various block types for Slack messages.\nFirst, let’s start at the top of the message, which would be the message’s header:\n\nsource\n\n\n\n\n BlockBuilder.create_header_block (text:str)\n\n*Create a header block for Slack messages.\nArgs: text: The text to display in the header\nReturns: Slack block kit header object*\n\ntest_eq(BlockBuilder.create_header_block('My Text'),{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}})\n\nBlockBuilder.create_header_block('My Text')\n\n{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}}\n\n\nThat looks correct!\nNow, what about making the various sections in our message? We basically just need another simple method that takes in the section text and outputs the right formating for the Slack API\n\nsource\n\n\n\n\n BlockBuilder.create_section_block (text:str,\n                                    fields:Optional[List[Dict[str,Any]]]=N\n                                    one)\n\n*Create a section block for Slack messages.\nArgs: text: The text to display in the section fields: Optional list of field objects for the section\nReturns: Slack block kit section object*\n\ntest_eq(BlockBuilder.create_section_block('My Section'),{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n)\n\nBlockBuilder.create_section_block('My Section')\n\n{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n\n\nOR, if we want the section to have some detial fields:\n\ntest_eq(BlockBuilder.create_section_block('My Section',['Some Field here']),\n        {'type': 'section','text': {'type': 'mrkdwn', 'text': 'My Section'},'fields': ['Some Field here']})\n\n\nBlockBuilder.create_section_block('My Section',['Some Field here'])\n\n{'type': 'section',\n 'text': {'type': 'mrkdwn', 'text': 'My Section'},\n 'fields': ['Some Field here']}\n\n\nPerfect! I guess we should should actually make a way to make fields then:\n\nsource\n\n\n\n\n BlockBuilder.create_field (title:str, value:str)\n\n*Create a field for a section block.\nArgs: title: The title of the field (will be bolded) value: The value of the field\nReturns: Field object for use in section blocks*\n\ntest_eq(BlockBuilder.create_field('The Top, Important Part','Less important Part'),\n        {'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'})\n\nBlockBuilder.create_field('The Top, Important Part','Less important Part')\n\n{'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'}\n\n\nThat would be used for things like BlockBuilder.create_field(column_name,row_value) to add the column details to the message\nNow that we can make an individual field, let’s make a way to take in multiple fields and turn them into a section since we’ll often want to show the values for multiple columns:\n\nsource\n\n\n\n\n BlockBuilder.create_fields_section (fields_data:List[Tuple[str,str]],\n                                     max_fields_per_section:int=10)\n\n*Create one or more section blocks with fields.\nArgs: fields_data: List of (label, value) tuples max_fields_per_section: Maximum fields per section (Slack limit is 10)\nReturns: List of section blocks*\nLet’s pretend we are trying to make a section that has fiels for a center’s billing rate and company status since we send some alerts that do that:\n\nBlockBuilder.create_fields_section([('Billing Rate','$13'),('Company Status','Advertiser')])\n\n[{'type': 'section',\n  'fields': [{'type': 'mrkdwn', 'text': '*Billing Rate*\\n$13'},\n   {'type': 'mrkdwn', 'text': '*Company Status*\\nAdvertiser'}]}]\n\n\n\n\n\nsection_fields.png\n\n\nWow, that looks great!\nLet’s also add a method for making context blocks since that is a subtle way to add text/information to a message.\n\nsource\n\n\n\n\n BlockBuilder.create_context_block (text:str)\n\n*Create a context block for Slack messages.\nArgs: text: The text to show in the context block\nReturns: Slack block kit context object*\n\ntest_eq(BlockBuilder.create_context_block('Here is some informaiton'),{'type': 'context','elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]})\n\nBlockBuilder.create_context_block('Here is some informaiton')\n\n{'type': 'context',\n 'elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]}\n\n\nWe also probably want a way to make dividers since those are always helpful for layout messages:\n\nsource\n\n\n\n\n BlockBuilder.create_divider ()\n\n*Create a divider block for Slack messages.\nReturns: Slack block kit divider object*\n\ntest_eq(BlockBuilder.create_divider(),{'type': 'divider'})\n\nBlockBuilder.create_divider()\n\n{'type': 'divider'}\n\n\nSince would like to allow users to add metadata to messages (which is helpful for processing the messages by the slack bot), let’s also create a method for turning column values into message context:\n\nsource\n\n\n\n\n BlockBuilder.create_metadata_context\n                                       (metadata_items:List[Tuple[str,Unio\n                                       n[str,List,dict]]])\n\n*Create a context block for metadata items.\nArgs: metadata_items: List of (label, value) tuples\nReturns: Formatted metadata field*\n\ntest_eq(\n    BlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})]),\n    {'metadata': \n        {'Sheet Owner': 'Mary',\n        'Sheet Editors': ['Joe', 'John', 'Bill'],\n        'Budfet': {\n            'Shared': False,\n            'Uses Parent': False,\n            'individual_budget': 9000}}})\n\n\nBlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})])\n\n{'metadata': {'Sheet Owner': 'Mary',\n  'Sheet Editors': ['Joe', 'John', 'Bill'],\n  'Budfet': {'Shared': False,\n   'Uses Parent': False,\n   'individual_budget': 9000}}}",
    "crumbs": [
      "API",
      "block_builder"
    ]
  },
  {
    "objectID": "API/block_builder.html#creating-a-slack-builder-class",
    "href": "API/block_builder.html#creating-a-slack-builder-class",
    "title": "block_builder",
    "section": "",
    "text": "source\n\n\n\n BlockBuilder ()\n\nUtility class for building Slack Block Kit elements. Provides methods to create various block types for Slack messages.\nFirst, let’s start at the top of the message, which would be the message’s header:\n\nsource\n\n\n\n\n BlockBuilder.create_header_block (text:str)\n\n*Create a header block for Slack messages.\nArgs: text: The text to display in the header\nReturns: Slack block kit header object*\n\ntest_eq(BlockBuilder.create_header_block('My Text'),{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}})\n\nBlockBuilder.create_header_block('My Text')\n\n{'type': 'header',\n 'text': {'type': 'plain_text', 'text': 'My Text', 'emoji': True}}\n\n\nThat looks correct!\nNow, what about making the various sections in our message? We basically just need another simple method that takes in the section text and outputs the right formating for the Slack API\n\nsource\n\n\n\n\n BlockBuilder.create_section_block (text:str,\n                                    fields:Optional[List[Dict[str,Any]]]=N\n                                    one)\n\n*Create a section block for Slack messages.\nArgs: text: The text to display in the section fields: Optional list of field objects for the section\nReturns: Slack block kit section object*\n\ntest_eq(BlockBuilder.create_section_block('My Section'),{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n)\n\nBlockBuilder.create_section_block('My Section')\n\n{'type': 'section', 'text': {'type': 'mrkdwn', 'text': 'My Section'}}\n\n\nOR, if we want the section to have some detial fields:\n\ntest_eq(BlockBuilder.create_section_block('My Section',['Some Field here']),\n        {'type': 'section','text': {'type': 'mrkdwn', 'text': 'My Section'},'fields': ['Some Field here']})\n\n\nBlockBuilder.create_section_block('My Section',['Some Field here'])\n\n{'type': 'section',\n 'text': {'type': 'mrkdwn', 'text': 'My Section'},\n 'fields': ['Some Field here']}\n\n\nPerfect! I guess we should should actually make a way to make fields then:\n\nsource\n\n\n\n\n BlockBuilder.create_field (title:str, value:str)\n\n*Create a field for a section block.\nArgs: title: The title of the field (will be bolded) value: The value of the field\nReturns: Field object for use in section blocks*\n\ntest_eq(BlockBuilder.create_field('The Top, Important Part','Less important Part'),\n        {'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'})\n\nBlockBuilder.create_field('The Top, Important Part','Less important Part')\n\n{'type': 'mrkdwn', 'text': '*The Top, Important Part*\\nLess important Part'}\n\n\nThat would be used for things like BlockBuilder.create_field(column_name,row_value) to add the column details to the message\nNow that we can make an individual field, let’s make a way to take in multiple fields and turn them into a section since we’ll often want to show the values for multiple columns:\n\nsource\n\n\n\n\n BlockBuilder.create_fields_section (fields_data:List[Tuple[str,str]],\n                                     max_fields_per_section:int=10)\n\n*Create one or more section blocks with fields.\nArgs: fields_data: List of (label, value) tuples max_fields_per_section: Maximum fields per section (Slack limit is 10)\nReturns: List of section blocks*\nLet’s pretend we are trying to make a section that has fiels for a center’s billing rate and company status since we send some alerts that do that:\n\nBlockBuilder.create_fields_section([('Billing Rate','$13'),('Company Status','Advertiser')])\n\n[{'type': 'section',\n  'fields': [{'type': 'mrkdwn', 'text': '*Billing Rate*\\n$13'},\n   {'type': 'mrkdwn', 'text': '*Company Status*\\nAdvertiser'}]}]\n\n\n\n\n\nsection_fields.png\n\n\nWow, that looks great!\nLet’s also add a method for making context blocks since that is a subtle way to add text/information to a message.\n\nsource\n\n\n\n\n BlockBuilder.create_context_block (text:str)\n\n*Create a context block for Slack messages.\nArgs: text: The text to show in the context block\nReturns: Slack block kit context object*\n\ntest_eq(BlockBuilder.create_context_block('Here is some informaiton'),{'type': 'context','elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]})\n\nBlockBuilder.create_context_block('Here is some informaiton')\n\n{'type': 'context',\n 'elements': [{'type': 'mrkdwn', 'text': 'Here is some informaiton'}]}\n\n\nWe also probably want a way to make dividers since those are always helpful for layout messages:\n\nsource\n\n\n\n\n BlockBuilder.create_divider ()\n\n*Create a divider block for Slack messages.\nReturns: Slack block kit divider object*\n\ntest_eq(BlockBuilder.create_divider(),{'type': 'divider'})\n\nBlockBuilder.create_divider()\n\n{'type': 'divider'}\n\n\nSince would like to allow users to add metadata to messages (which is helpful for processing the messages by the slack bot), let’s also create a method for turning column values into message context:\n\nsource\n\n\n\n\n BlockBuilder.create_metadata_context\n                                       (metadata_items:List[Tuple[str,Unio\n                                       n[str,List,dict]]])\n\n*Create a context block for metadata items.\nArgs: metadata_items: List of (label, value) tuples\nReturns: Formatted metadata field*\n\ntest_eq(\n    BlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})]),\n    {'metadata': \n        {'Sheet Owner': 'Mary',\n        'Sheet Editors': ['Joe', 'John', 'Bill'],\n        'Budfet': {\n            'Shared': False,\n            'Uses Parent': False,\n            'individual_budget': 9000}}})\n\n\nBlockBuilder.create_metadata_context([('Sheet Owner','Mary'),\n                                  ('Sheet Editors',['Joe','John','Bill']),\n                                  ('Budfet',{'Shared':False,'Uses Parent':False,'individual_budget':9000})])\n\n{'metadata': {'Sheet Owner': 'Mary',\n  'Sheet Editors': ['Joe', 'John', 'Bill'],\n  'Budfet': {'Shared': False,\n   'Uses Parent': False,\n   'individual_budget': 9000}}}",
    "crumbs": [
      "API",
      "block_builder"
    ]
  },
  {
    "objectID": "API/core.html",
    "href": "API/core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nDebugLogger\n\n DebugLogger ()\n\nSimple debug logger to centralize logging logic.\n\nsource\n\n\nColumnUtils\n\n ColumnUtils ()\n\nUtilities for column operations in DataFrames.\n\nsource\n\n\nValueFormatter\n\n ValueFormatter ()\n\nHandles formatting of different data types for display.\n\nsource\n\n\nSlackFormatter\n\n SlackFormatter ()\n\nUtilities for formatting data for Slack messages.\n\nsource\n\n\nSlackMessenger\n\n SlackMessenger ()\n\nHandles creation and sending of Slack messages in various templates.\n\nsource\n\n\nActionIdManager\n\n ActionIdManager ()\n\nManages action IDs for Slack interactive elements to ensure uniqueness and provide routing capabilities for action handlers.",
    "crumbs": [
      "API",
      "core"
    ]
  },
  {
    "objectID": "API/message_templates.html",
    "href": "API/message_templates.html",
    "title": "message_templates",
    "section": "",
    "text": "class MessageTemplates:\n    \"\"\"Refactored templates using modular components.\"\"\"\n    \n    @staticmethod\n    def _send_messages_and_log(\n        messages: List[Tuple[str, List[Dict[str, Any]], Dict[str, Any]]],\n        view: str,\n        view_group: str,\n        channel_id: str,\n        send_to_slack_func: Callable,\n        log_alert_history_func: Callable\n    ) -&gt; Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"Send multiple messages and log results.\n        \n        Args:\n            messages: List of (message_text, blocks, row_data) tuples\n            view: View name\n            view_group: View group name\n            channel_id: Slack channel ID\n            send_to_slack_func: Function to send messages to Slack\n            log_alert_history_func: Function to log alert history\n            \n        Returns:\n            Tuple of (success_flag, error_details)\n        \"\"\"\n        all_success = True\n        all_errors = []\n        \n        for idx, (message_text, payload_blocks, row_data) in enumerate(messages):\n            DebugLogger.log(f'Sending message for {view} - Item {idx}')\n            DebugLogger.log(f'Payload Blocks: {json.dumps(payload_blocks, default=str)}')\n            \n            # Send to Slack with error handling\n            success, error_details = SlackMessenger._send_alert_to_slack(\n                send_to_slack_func, \n                channel_id, \n                message_text, \n                payload_blocks, \n                f\"{view}_item_{idx}\"\n            )\n            \n            if not success:\n                all_success = False\n                all_errors.append({f\"item_{idx}\": error_details})\n            \n            # Format row data for logging\n            formatted_data = SlackMessenger._format_data_for_logging(row_data)\n            \n            # Log alert history\n            SlackMessenger._log_alert(\n                log_alert_history_func,\n                view=view,\n                view_group=view_group,\n                channel_id=channel_id,\n                success=success,\n                error_details=error_details,\n                formatted_data=formatted_data,\n                message_text=message_text\n            )\n        \n        return all_success, all_errors if not all_success else None\n    \n    @classmethod\n    def template_f1(\n        cls,\n        df: pd.DataFrame,\n        view: str,\n        view_group: str,\n        message_text: str,\n        channel_id: str,\n        view_config: Dict[str, Any],\n        send_to_slack_func: Callable,\n        log_alert_history_func: Callable,\n    ) -&gt; Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"Slack Message Format 1: Single message with row sections and details on the right.\n        \n        Args:\n            df: DataFrame with alert data\n            view: View name\n            view_group: Group name for the view\n            message_text: Main message text\n            channel_id: Slack channel ID\n            view_config: Configuration for the view\n            send_to_slack_func: Function to send messages to Slack\n            log_alert_history_func: Function to log alert history\n            \n        Returns:\n            Tuple of (success_flag, error_details)\n        \"\"\"\n        DebugLogger.log(f'Processing template_f1 for view: {view}')\n        \n        # Create title from view name\n        title = view.lower().replace(view_group, '').replace('_', ' ').title()\n        \n        # Initialize blocks with header\n        payload_blocks = [BlockBuilder.create_header_block(title)]\n        \n        # Get columns for details\n        df_columns = list(df.columns)\n        detail_columns = (\n            view_config.get('detail_columns') \n            if 'detail_columns' in view_config \n            else ColumnUtils.get_detail_columns(df_columns)\n        )\n        \n        DebugLogger.log(f'df_columns: {df_columns}')\n        DebugLogger.log(f'detail_columns: {detail_columns}')\n        \n        # Process each row into a section\n        for idx, row in df.iterrows():\n            detail_text = SlackFormatter.right_hand_details(row, detail_columns, df)\n            section_text = SlackFormatter.format_section_name(row, df_columns)\n            payload_blocks.append(BlockBuilder.process_section_row(section_text, detail_text))\n        \n        DebugLogger.log(f'Payload Blocks: {json.dumps(payload_blocks, default=str)}')\n        print(f'   Sending Alert for {view}')\n        \n        # Send to Slack with error handling\n        success, error_details = SlackMessenger._send_alert_to_slack(\n            send_to_slack_func, \n            channel_id, \n            message_text, \n            payload_blocks, \n            view\n        )\n        \n        # Format data for logging\n        formatted_data = SlackMessenger._format_data_for_logging(df)\n        \n        # Log alert history\n        SlackMessenger._log_alert(\n            log_alert_history_func,\n            view=view,\n            view_group=view_group,\n            channel_id=channel_id,\n            success=success,\n            error_details=error_details,\n            formatted_data=formatted_data,\n            message_text=message_text\n        )\n        \n        return success, error_details\n    \n    @classmethod\n    def template_f2(\n        cls,\n        df: pd.DataFrame,\n        view: str,\n        view_group: str,\n        message_text: str,\n        channel_id: str,\n        view_config: Dict[str, Any],\n        send_to_slack_func: Callable,\n        log_alert_history_func: Callable,\n    ) -&gt; Tuple[bool, Optional[Dict[str, Any]]]:\n        \"\"\"Slack Message Format 2: Individual interactive messages for each row.\n        \n        Args:\n            df: DataFrame with alert data\n            view: View name\n            view_group: Group name for the view\n            message_text: Main message text\n            channel_id: Slack channel ID\n            view_config: Configuration for the view\n            send_to_slack_func: Function to send messages to Slack\n            log_alert_history_func: Function to log alert history\n            \n        Returns:\n            Tuple of (success_flag, error_details)\n        \"\"\"\n        DebugLogger.log(f'Processing template_f2 for view: {view}')\n        \n        # Normalize column names for case-insensitive access\n        df_columns = list(df.columns)\n        col_map = ColumnUtils.normalize_columns(df_columns)\n        \n        # Prepare messages for each row\n        messages = []\n        \n        # Process each row\n        for idx, row in df.iterrows():\n            # Get row-specific config or fallback to view_config\n            config = TemplateEngine._parse_row_config(row, view_config, col_map)\n            \n            # Build message blocks for this row\n            payload_blocks = TemplateEngine.build_individual_message_blocks(\n                row, df_columns, col_map, config, view\n            )\n            \n            # Message text can be customized per row or use the default\n            row_message_col = col_map.get('MESSAGE_TEXT')\n            row_message = row[row_message_col] if row_message_col and pd.notna(row[row_message_col]) else message_text\n            \n            # Add to message list\n            messages.append((row_message, payload_blocks, pd.DataFrame([row])))\n        \n        # Send messages and log results\n        return cls._send_messages_and_log(\n            messages, view, view_group, channel_id, send_to_slack_func, log_alert_history_func\n        )",
    "crumbs": [
      "API",
      "message_templates"
    ]
  }
]